/*
 * Copyright 2020 Cool Squad Team
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.nus.cool.core.iceberg.query;

import com.nus.cool.core.cohort.filter.FieldFilter;
import com.nus.cool.core.cohort.filter.FieldFilterFactory;
import com.nus.cool.core.io.readstore.ChunkRS;
import com.nus.cool.core.io.readstore.FieldRS;
import com.nus.cool.core.io.readstore.MetaChunkRS;
import com.nus.cool.core.io.readstore.MetaFieldRS;
import com.nus.cool.core.io.storevector.InputVector;
import com.nus.cool.core.schema.FieldType;
import com.nus.cool.core.schema.TableSchema;
import com.nus.cool.core.util.converter.DayIntConverter;
import com.sun.istack.internal.Nullable;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * @author hongbin
 * @version 0.1
 * @since 0.1
 */
public class IcebergSelection {

  /**
   * cublet is activate or not
   */
  private boolean bActivateCublet;

  /**
   * schema of the cublet
   */
  private TableSchema tableSchema;

  /**
   * filter generated by query
   */
  private SelectionFilter filter;

  /**
   * meta chunk of the cublet
   */
  private MetaChunkRS metaChunk;

  /**
   * time range defined in query
   */
  private String timeRange;

  /**
   * max value of time range
   */
  private int maxDate;

  /**
   * min value of time range
   */
  private int minDate;

  /**
   *
   */
  private List<String> timeRanges = new ArrayList<>();

  private List<Integer> maxs = new ArrayList<>();

  private List<Integer> mins = new ArrayList<>();

  /**
   * Init iceberg selection
   *
   * @param tableSchema schema of the cublet
   * @param query iceberg query
   * @throws ParseException Illegal time format input
   */
  public void init(TableSchema tableSchema, IcebergQuery query) throws ParseException {
    this.tableSchema = tableSchema;
    SelectionQuery selection = query.getSelection();
    this.filter = init(selection);

    if (query.getTimeRange() != null) {
      this.timeRange = query.getTimeRange();
      // Time range format as [begin|end]
      String[] timePoints = this.timeRange.split("\\|");
      DayIntConverter converter = new DayIntConverter();
      this.minDate = converter.toInt(timePoints[0]);
      this.maxDate = converter.toInt(timePoints[1]);
      splitTimeRange(query.getGranularity());
    }
  }

  /**
   * Process meta chunk to check if the cublet is active
   *
   * @param metaChunk MetaChunk of the cublet
   */
  public void process(MetaChunkRS metaChunk) {
    this.metaChunk = metaChunk;
    MetaFieldRS timeField = metaChunk
        .getMetaField(this.tableSchema.getActionTimeField(), FieldType.ActionTime);
    this.bActivateCublet = accept(timeField.getMinValue(), timeField.getMaxValue())
        && process(this.filter, metaChunk);
  }

  /**
   * Process data chunk and return bitsets for time ranges
   *
   * @param chunk  data chunk
   * @param bitSet
   * @return
   */
  public Map<String, BitSet> process(ChunkRS chunk, BitSet bitSet) {
    FieldRS timeField = chunk.getField(this.tableSchema.getActionTimeField());
    int minKey = timeField.minKey();
    int maxKey = timeField.maxKey();
    // check this data chunk is acceptable or not
    if (!(accept(minKey, maxKey) && process(this.filter, chunk))) {
      return null;
    }

    Map<String, BitSet> map = new HashMap<>();
    // TODO not necessary
    if (this.timeRange == null) {
      map.put("no time filter", bitSet);
    } else {
      int tag = 0;
      while (minKey > this.maxs.get(tag)) {
        tag += 1;
      }
      if (minKey >= this.mins.get(tag) && maxKey <= this.maxs.get(tag)) {
        // Time range contains all data in this chunk
        BitSet bv = new BitSet(chunk.getRecords());
        bv.set(0, chunk.getRecords());
        map.put(this.timeRanges.get(tag), bv);
      } else {
        InputVector timeInput = timeField.getValueVector();
        timeInput.skipTo(0);
        BitSet[] bitSets = new BitSet[this.timeRanges.size()];
        for (int i = 0; i < this.timeRanges.size(); i++) {
          bitSets[i] = new BitSet(chunk.getRecords());
        }
        int max = this.maxs.get(tag);
        for (int i = 0; i < timeInput.size(); i++) {
          int time = timeInput.next();
          if (time < this.minDate) {
            continue;
          }
          if (time > this.maxDate) {
            break;
          }
          if (time > max) {
            while (!(time >= this.mins.get(tag) && (time <= this.maxs.get(tag)))) {
              tag += 1;
            }
            max = this.maxs.get(tag);
          }
          bitSets[tag].set(i);
        }
        for (int i = 0; i < bitSets.length; i++) {
          if (bitSets[i].cardinality() != 0) {
            map.put(this.timeRanges.get(i), bitSets[i]);
          }
        }
      }
    }
    for (Map.Entry<String, BitSet> entry : map.entrySet()) {
      BitSet bs = select(this.filter, chunk, entry.getValue());
      map.put(entry.getKey(), bs);
    }
    return map;
  }

  public boolean isbActivateCublet() {
    return this.bActivateCublet;
  }

  /**
   * Split time ranges according to granularity
   *
   * @param granularity Time granularity in query
   * @throws ParseException Illegal time format input
   */
  private void splitTimeRange(IcebergQuery.granularityType granularity) throws ParseException {
    DayIntConverter converter = new DayIntConverter();
    switch (granularity) {
      case DAY:
        for (int i = 0; i < this.maxDate - this.minDate; i++) {
          int time = this.minDate + i;
          this.maxs.add(time);
          this.mins.add(time);
          this.timeRanges.add(converter.getString(time));
        }
        break;
      case MONTH: {
        String[] timePoints = this.timeRange.split("\\|");
        Date d1 = new SimpleDateFormat("yyyy-MM").parse(timePoints[0]);
        Date d2 = new SimpleDateFormat("yyyy-MM").parse(timePoints[1]);
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(d2);
        calendar.add(Calendar.MONTH, 2);
        d2 = calendar.getTime();
        calendar.setTime(d1);
        List<String> points = new ArrayList<>();
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
        while (calendar.getTime().before(d2)) {
          points.add(sdf.format(calendar.getTime()));
          calendar.add(Calendar.MONTH, 1);
        }
        for (int i = 0; i < points.size() - 1; i++) {
          this.timeRanges.add(points.get(i) + "|" + points.get(i + 1));
          this.mins.add(converter.toInt(points.get(i)));
          this.maxs.add(converter.toInt(points.get(i + 1)) - 1);
        }
        this.mins.set(0, this.minDate);
        this.maxs.set(this.maxs.size() - 1, this.maxDate);
        break;
      }
      case YEAR: {
        String[] timePoints = this.timeRange.split("\\|");
        Date d1 = new SimpleDateFormat("yyyy").parse(timePoints[0]);
        Date d2 = new SimpleDateFormat("yyyy").parse(timePoints[1]);
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(d2);
        calendar.add(Calendar.YEAR, 2);
        d2 = calendar.getTime();
        calendar.setTime(d1);
        List<String> points = new ArrayList<>();
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
        while (calendar.getTime().before(d2)) {
          points.add(sdf.format(calendar.getTime()));
          calendar.add(Calendar.YEAR, 1);
        }
        for (int i = 0; i < points.size() - 1; i++) {
          this.timeRanges.add(points.get(i) + "|" + points.get(i + 1));
          this.mins.add(converter.toInt(points.get(i)));
          this.maxs.add(converter.toInt(points.get(i + 1)));
        }
        break;
      }
      case NULL:
        this.maxs.add(this.maxDate);
        this.mins.add(this.minDate);
        this.timeRanges.add(this.timeRange);
        break;
      default:
        throw new IllegalArgumentException();
    }
  }

  /**
   * @param bs
   * @param field
   * @param filter
   */
  private void selectFields(BitSet bs, FieldRS field, FieldFilter filter) {
    InputVector fieldIn = field.getValueVector();
    int off = 0;
    while (off < fieldIn.size() && off >= 0) {
      fieldIn.skipTo(off);
      if (!filter.accept(fieldIn.next())) {
        bs.clear(off);
      }
      off = bs.nextSetBit(off + 1);
    }
  }

  /**
   * Init selection filter, if selection query is null then return null
   *
   * @param selection Selection query in iceberg query
   * @return Selection filter
   */
  private SelectionFilter init(@Nullable SelectionQuery selection) {
    if (selection == null) {
      return null;
    }
    SelectionFilter filter = new SelectionFilter();
    filter.setType(selection.getType());
    if (filter.getType().equals(SelectionQuery.SelectionType.FILTER)) {
      FieldFilter fieldFilter = FieldFilterFactory.create(
          this.tableSchema.getField(selection.getDimension()), selection.getValues());
      filter.setFilter(fieldFilter);
      filter.setDimension(selection.getDimension());
    } else {
      for (SelectionQuery childSelection : selection.getFields()) {
        SelectionFilter childFilter = init(childSelection);
        filter.getFields().add(childFilter);
      }
    }
    return filter;
  }

  /**
   * Check the cublet is processable, if filter is not exist then always return true
   *
   * @param selectionFilter filter generated by query
   * @param metaChunk       meta chunk of cublet
   * @return processable or not
   */
  private boolean process(@Nullable SelectionFilter selectionFilter, MetaChunkRS metaChunk) {
    if (selectionFilter == null) {
      return true;
    }
    if (selectionFilter.getType().equals(SelectionQuery.SelectionType.FILTER)) {
      MetaFieldRS metaField = metaChunk.getMetaField(selectionFilter.getDimension());
      return selectionFilter.getFilter().accept(metaField);
    } else {
      boolean flag = selectionFilter.getType().equals(SelectionQuery.SelectionType.AND);
      for (SelectionFilter childFilter : selectionFilter.getFields()) {
        if (selectionFilter.getType().equals(SelectionQuery.SelectionType.AND)) {
          flag &= process(childFilter, metaChunk);
        } else {
          flag |= process(childFilter, metaChunk);
        }
      }
      return flag;
    }
  }

  /**
   * Check the data chunk is processable, if filter is not exist then always return true
   *
   * @param selectionFilter filter generated by query
   * @param chunk           data chunk
   * @return processable or not
   */
  private boolean process(@Nullable SelectionFilter selectionFilter, ChunkRS chunk) {
    if (selectionFilter == null) {
      return true;
    }
    if (selectionFilter.getType().equals(SelectionQuery.SelectionType.FILTER)) {
      FieldRS field = chunk.getField(selectionFilter.getDimension());
      return selectionFilter.getFilter().accept(field);
    } else {
      boolean flag = selectionFilter.getType().equals(SelectionQuery.SelectionType.AND);
      for (SelectionFilter childFilter : selectionFilter.getFields()) {
        if (selectionFilter.getType().equals(SelectionQuery.SelectionType.AND)) {
          flag &= process(childFilter, chunk);
        } else {
          flag |= process(childFilter, chunk);
        }
      }
      return flag;
    }
  }

  /**
   * Process selection, while filter is not exist then do nothing but return bv
   *
   * @param selectionFilter filter generated by query
   * @param chunk           data chunk
   * @param bv              bitset for specific time range
   * @return bitset present selection result
   */
  private BitSet select(@Nullable SelectionFilter selectionFilter, ChunkRS chunk, BitSet bv) {
    BitSet bs = (BitSet) bv.clone();
    if (selectionFilter == null) {
      return bs;
    }
    if (selectionFilter.getType().equals(SelectionQuery.SelectionType.FILTER)) {
      FieldRS field = chunk.getField(this.tableSchema.getFieldID(selectionFilter.getDimension()));
      InputVector keyVector = field.getKeyVector();
      BitSet[] bitSets = field.getBitSets();
      if (field.isPreCal()) {
        List<String> values = selectionFilter.getFilter().getValues();
        BitSet matchedBitSet = new BitSet();
        for (String value : values) {
          int gId = this.metaChunk.getMetaField(selectionFilter.getDimension()).find(value);
          int localId = keyVector.find(gId);
          matchedBitSet.or(bitSets[localId]);
        }
        bs.and(matchedBitSet);
      } else {
        selectFields(bs, field, selectionFilter.getFilter());
      }
    } else if (selectionFilter.getType().equals(SelectionQuery.SelectionType.AND)) {
      for (SelectionFilter childFilter : selectionFilter.getFields()) {
        bs = select(childFilter, chunk, bs);
      }
    } else if (selectionFilter.getType().equals(SelectionQuery.SelectionType.OR)) {
      List<BitSet> bitSets = new ArrayList<>();
      for (SelectionFilter childFilter : selectionFilter.getFields()) {
        bitSets.add(select(childFilter, chunk, bs));
      }
      bs = orBitSets(bitSets);
    }
    return bs;
  }

  /**
   * Perform a logical OR of bitset in the list
   *
   * @param bitSets bitset list
   * @return result
   */
  private BitSet orBitSets(List<BitSet> bitSets) {
    BitSet bs = bitSets.get(0);
    for (int i = 1; i < bitSets.size(); i++) {
      bs.or(bitSets.get(i));
    }
    return bs;
  }

  /**
   * Check time range is acceptable to the chunk
   *
   * @param min Min value of time in the chunk
   * @param max Max value of time in the chunk
   * @return acceptable or not
   */
  private boolean accept(int min, int max) {
    if (this.timeRange == null) {
      return true;
    }
    return (min <= this.maxDate) && (max >= this.minDate);
  }
}
